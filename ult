#!/usr/bin/env python3
# encoding=UTF-8

# Copyright Â© 2021 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import collections
import ctypes
import fractions
import functools
import gzip
import re
import sys
import typing
import unicodedata

type(0_0)  # Python >= 3.6 is required

prog = argparse.ArgumentParser().prog

def error(msg):
    print(f'{prog}: {msg}', file=sys.stderr)
    sys.exit(1)

def cache(f):
    return functools.lru_cache(maxsize=1)(f)

@cache
def _get_mnemonic_data():
    seen = set()
    data = {}
    path = '/usr/share/doc/RFC/links/rfc1345.txt.gz'
    errata_chars= {
        # https://www.rfc-editor.org/errata/eid2683
        '\N{LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW}',
        '\N{LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE}',
    }
    with gzip.open(path, 'rt', encoding='ASCII') as file:
        for line in file:
            match = re.match(r'^ (\S+) +([0-9a-f]{4}) +[A-Z]', line)
            if match:
                (s, pt) = match.groups()
                pt = int(pt, 16)
                ch = chr(pt)
                if ch in errata_chars:
                    assert s[0].upper()
                    s = s[0].lower() + s[1:]
                if s in seen:
                    raise RuntimeError(f'{path}: mnemonic {s!r} already seen')
                seen |= {s}
                if ch in data:
                    raise RuntimeError(f'{path}: U+{pt:04X} already seen')
                data[ch] = s
    return data

def get_mnemonic(ch):
    return _get_mnemonic_data().get(ch)

_x11_keys = dict(
    space=' ',
    exclam='!',
    quotedbl='"',
    numbersign='#',
    percent='%',
    apostrophe="'",
    parenright=')',
    parenleft='(',
    asterisk='*',
    plus='+',
    comma=',',
    minus='-',
    period='.',
    slash='/',
    colon=':',
    semicolon=';',
    equal='=',
    question='?',
    bracketleft='[',
    backslash='\\',
    bracketright=']',
    asciicircum='^',
    underscore='_',
    grave='`',
    braceleft='{',
    bar='|',
    braceright='}',
    asciitilde='~',
)

@cache
def _get_x11_seq_data():
    data = collections.defaultdict(list)
    path = '/usr/share/X11/locale/en_US.UTF-8/Compose'
    with open(path, 'rt', encoding='UTF-8') as file:
        for line in file:
            if line[:1] in {'#', '\n'}:
                continue
            match = re.match(r'(\S.*):\s*"(.*)"', line)
            if match is None:
                raise RuntimeError(f'{path}: cannot parse line {line!r}')
            (seq, ch) = match.groups()
            if len(ch) != 1:
                continue
            seq = seq.rstrip()
            def subst(match):
                orig = match.group()
                key = match.group(1)
                if len(key) == 1:
                    return key
                try:
                    return _x11_keys[key]
                except KeyError:
                    return orig
            seq = re.sub(r'<(\w+)>', subst, seq)
            data[ch] += [seq]
    return data

def get_x11_seqs(ch):
    return _get_x11_seq_data().get(ch)

class Alias(typing.NamedTuple):
    name: str
    label: str

@cache
def _get_alias_data():
    data = collections.defaultdict(list)
    path = '/usr/share/unicode/NameAliases.txt'
    with open(path, 'rt', encoding='UTF-8') as file:
        for line in file:
            line = line.rstrip('\n')
            if line[:1] in {'#', ''}:
                continue
            (pt, name, label) = line.split(';')
            ch = chr(int(pt, 16))
            data[ch] += [Alias(name, label)]
    return data

def get_aliases(ch):
    return _get_alias_data().get(ch)

_libunl = ctypes.CDLL('libuninameslist.so.1')

# const char *uniNamesList_annot(unsigned long uni);
_libunl_annot = _libunl.uniNamesList_annot
_libunl_annot.argtypes = [ctypes.c_long]
_libunl_annot.restype = ctypes.c_char_p

class Annot(typing.NamedTuple):
    see_also: list

def get_annot(ch):
    pt = ord(ch)
    s = _libunl_annot(pt)
    if s is None:
        return Annot([])
    s = s.decode('UTF-8')
    codes = 'x*:#%=~'
    lists = {}
    for code in codes:
        lists[code] = []
    for line in s.splitlines():
        match = re.match(fr'\A\t([{re.escape(codes)}]) (\S.*)\Z', line)
        if match is None:
            raise RuntimeError(f'U+{pt:04X} annotations: cannot parse line {line!r}')
        (code, s) = match.groups()
        if code == 'x':
            match = re.match(r'\A(?:[(].* - ([0-9A-F]{4,})[)]|([0-9A-F]{4,}))\Z', s)
            if match is None:
                raise RuntimeError(f'U+{pt:04X} annotations: cannot parse line {line!r}')
            pt = int(match.group(1) or match.group(2), 16)
            s = chr(pt)
        lst = lists[code]
        lst += [s]
    return Annot(
        see_also=lists['x'],
    )

# int uniNamesList_blockNumber(unsigned long uni);
_libunl_block_no = _libunl.uniNamesList_blockNumber
_libunl_block_no.argtypes = [ctypes.c_long]
_libunl_block_no.restype = ctypes.c_int

# long uniNamesList_blockStart(int uniBlock);
_libunl_block_start = _libunl.uniNamesList_blockStart
_libunl_block_start.argtypes = [ctypes.c_int]
_libunl_block_start.restype = ctypes.c_long

# long uniNamesList_blockEnd(int uniBlock);
_libunl_block_end = _libunl.uniNamesList_blockEnd
_libunl_block_end.argtypes = [ctypes.c_int]
_libunl_block_end.restype = ctypes.c_long

# const char *uniNamesList_blockName(int uniBlock);
_libunl_block_name = _libunl.uniNamesList_blockName
_libunl_block_name.argtypes = [ctypes.c_int]
_libunl_block_name.restype = ctypes.c_char_p

class Block(typing.NamedTuple):
    start: int
    stop: int
    name: str

def get_block(ch):
    pt = ord(ch)
    i = _libunl_block_no(pt)
    if i < 0:
        return None
    start = _libunl_block_start(i)
    stop = _libunl_block_end(i)
    name = _libunl_block_name(i).decode('UTF-8')
    return Block(start, stop, name)

@cache
def _get_prop_alias_data():
    data = collections.defaultdict(dict)
    path = '/usr/share/unicode/PropertyValueAliases.txt'
    with open(path, 'rt', encoding='UTF-8') as file:
        for line in file:
            line = line.partition('#')[0]
            line = line.rstrip()
            if not line:
                continue
            line = line.split(';')
            (prop, k1, k2, *tail) = map(str.strip, line)
            del tail
            assert k1 not in data[prop], f'{prop}={k1} already seen'
            data[prop][k1] = k2
    return data

def get_category_alias(cat):
    return _get_prop_alias_data()['gc'][cat]

def float2frac(x):
    (n, d) = x.as_integer_ratio()
    (p0, q0, p1, q1) = (0, 1, 1, 0)
    while d != 0:
        a = n // d
        (p0, q0, p1, q1) = (p1, q1, p0 + a * p1, q0 + a * q1)
        (n, d) = (d, n - a * d)
        if p1 / q1 == x:
            return fractions.Fraction(p1, q1)
    raise ValueError

def get_numeric_value(ch):
    try:
        nv = unicodedata.numeric(ch)
    except ValueError:
        return None
    return float2frac(nv)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('name', metavar='NAME', nargs='+')
    options = ap.parse_args()
    name = ' '.join(options.name).upper()
    match = re.match(r'\AU[+]([0-9A-F]+)\Z', name)
    if match is None:
        try:
            ch = unicodedata.lookup(name)
        except KeyError as exc:
            error(exc.args[0])
        if len(ch) != 1:
            # TODO!
            error('support for named sequences is not implemented yet')
        pt = ord(ch)
    else:
        pt = int(match.group(1), 16)
        if pt > sys.maxunicode:
            error(f'code point out of range: 0x{pt:04X} > 0x{sys.maxunicode:X}')
        ch = chr(pt)
    name = unicodedata.name(ch, '')
    cat = unicodedata.category(ch)
    long_cat = get_category_alias(cat)
    if not name:
        if cat == 'Cn':
            name = 'non-character'
        elif cat == 'Cc':
            name = 'control character'
            if pt <= 0x1F:
                name += ' (C0)'
            elif 0x80 <= pt <= 0x9F:
                name += ' (C1)'
        elif cat == 'Cs':
            name = 'lone surrogate'
    print(f'U+{pt:04X}{name and " "}{name or ""}')
    aliases = get_aliases(ch)
    if aliases:
        print('Aliases:')
        for alias in aliases:
            print(f'  {alias.name} ({alias.label})')
    glyph = ch
    if cat[0] == 'C':
        glyph = None
    elif cat[0] == 'M':
        glyph = '\N{DOTTED CIRCLE}' + ch
    elif cat == 'Zs':
        glyph = f'[{glyph}]'
    if glyph:
        print(f'Text: {glyph}')
    mnemonic = get_mnemonic(ch)
    if mnemonic and mnemonic != ch:
        print(f'RFC-1345: {mnemonic}')
    x11_seqs = get_x11_seqs(ch)
    if x11_seqs:
        print('X11 multi-key input sequences:')
        for x11_seq in x11_seqs:
            print(' ', x11_seq)
    print(f'Category: {cat} ({long_cat})')
    block = get_block(ch)
    if block:
        print(f'Block: U+{block.start:04X}..U+{block.stop:04X} {block.name}')
    nv = get_numeric_value(ch)
    if nv is not None:
        print(f'Numeric value: {nv}')
    annots = get_annot(ch)
    if annots.see_also:
        print('See also:')
        for xch in annots.see_also:
            xpt = ord(xch)
            xname = unicodedata.name(xch, '')
            print(f'  U+{xpt:04X}{xname and " "}{xname or ""}')

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
