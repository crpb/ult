#!/usr/bin/env python3
# encoding=UTF-8

# Copyright Â© 2021 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import collections
import fractions
import functools
import gzip
import re
import sys
import unicodedata

0_0  # Python >= 3.6 is required

prog = argparse.ArgumentParser().prog

def error(msg):
    print(f'{prog}: {msg}', file=sys.stderr)
    sys.exit(1)

@functools.lru_cache(maxsize=1)
def get_mnemonics():
    seen = set()
    data = {}
    path = '/usr/share/doc/RFC/links/rfc1345.txt.gz'
    with gzip.open(path, 'rt', encoding='ASCII') as file:
        for line in file:
            match = re.match('^ (\S+) +([0-9a-f]{4}) +[A-Z]', line)
            if match:
                (s, pt) = match.groups()
                pt = int(pt, 16)
                ch = chr(pt)
                if ch in {'\N{LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW}', '\N{LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE}'}:
                    # https://www.rfc-editor.org/errata/eid2683
                    assert s[0].upper()
                    s = s[0].lower() + s[1:]
                assert s not in seen, f'{s!r} already seen'
                seen |= {s}
                assert ch not in data, f'U+{pt:04X} already seen'
                data[ch] = s
    return data

@functools.lru_cache(maxsize=1)
def get_x11_seqs():
    data = collections.defaultdict(list)
    path = '/usr/share/X11/locale/en_US.UTF-8/Compose'
    with open(path, 'rt', encoding='UTF-8') as file:
        for line in file:
            if line[:1] == '#':
                continue
            match = re.match(r'(\S.*):\s*"(.*)"', line)
            (seq, ch) = match.groups()
            if len(ch) != 1:
                continue
            data[ch] += [seq.rstrip()]
    return data

categories = dict(
    Lu='Uppercase_Letter',
    Ll='Lowercase_Letter',
    Lt='Titlecase_Letter',
    Lm='Modifier_Letter',
    Lo='Other_Letter',
    Mn='Nonspacing_Mark',
    Mc='Spacing_Mark',
    Me='Enclosing_Mark',
    Nd='Decimal_Number',
    Nl='Letter_Number',
    No='Other_Number',
    Pc='Connector_Punctuation',
    Pd='Dash_Punctuation',
    Ps='Open_Punctuation',
    Pe='Close_Punctuation',
    Pi='Initial_Punctuation',
    Pf='Final_Punctuation',
    Po='Other_Punctuation',
    Sm='Math_Symbol',
    Sc='Currency_Symbol',
    Sk='Modifier_Symbol',
    So='Other_Symbol',
    Zs='Space_Separator',
    Zl='Line_Separator',
    Zp='Paragraph_Separator',
    Cc='Control',
    Cf='Format',
    Cs='Surrogate',
    Co='Private_Use',
    Cn='Unassigned',
)

def float2frac(x):
    (n, d) = x.as_integer_ratio()
    (p0, q0, p1, q1) = (0, 1, 1, 0)
    while d != 0:
        a = n // d
        (p0, q0, p1, q1) = (p1, q1, p0 + a * p1, q0 + a * q1)
        (n, d) = (d, n - a * d)
        if p1 / q1 == x:
            return fractions.Fraction(p1, q1)
    raise ValueError

def get_numeric_value(ch):
    try:
        nv = unicodedata.numeric(ch)
    except ValueError:
        return
    return float2frac(nv)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('name', metavar='NAME', nargs='+')
    options = ap.parse_args()
    name = ' '.join(options.name).upper()
    match = re.match(r'\AU[+]([0-9A-F]+)\Z', name)
    if match is None:
        try:
            ch = unicodedata.lookup(name)
        except KeyError as exc:
            error(exc.args[0])
        if len(ch) != 1:
            # TODO!
            error('support for named sequences is not implemented yet')
        pt = ord(ch)
    else:
        pt = int(match.group(1), 16)
        if pt > 0x10FFFF:
            error(f'code point out of range: 0x{pt:04X} > 0x10FFFF')
        ch = chr(pt)
    name = unicodedata.name(ch, '')
    cat = unicodedata.category(ch)
    long_cat = categories[cat]
    if not name:
        if cat == 'Cn':
            name = 'non-character'
        elif cat == 'Cc':
            # TODO: elaborate
            name = 'control character'
        elif cat == 'Cs':
            name = 'lone surrogate'
    glyph = ch
    if cat[0] == 'C':
        glyph = None
    elif cat[0] == 'M':
        glyph = '\N{DOTTED CIRCLE}' + ch
    print(f'U+{pt:04X}{name and " "}{name or ""}')
    if glyph:
        print(f'Text: {glyph}')
    mnemonic = get_mnemonics().get(ch)
    if mnemonic and mnemonic != ch:
        print(f'RFC-1345: {mnemonic}')
    x11_seqs = get_x11_seqs().get(ch)
    if x11_seqs:
        print('X11 multi-key input sequences:')
        for x11_seq in x11_seqs:
            print(' ', x11_seq)
    print(f'Category: {cat} ({long_cat})')
    nv = get_numeric_value(ch)
    if nv is not None:
        print(f'Numeric value: {nv}')

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
